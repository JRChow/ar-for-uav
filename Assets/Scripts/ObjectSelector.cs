using System.Collections.Generic;
using System.Linq;
using System;
using DefaultNamespace;
using UnityEditor;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

public class ObjectSelector : MonoBehaviour
{
	public GameObject popupMenu;

	public GameObject indexButton;
	
	/// <summary>
	/// 2D points constituting the shape drawn by the user.
	/// </summary>
	private List<Vector3> _userDrawnShapePoints;

	// The minimum distance that the mouse has to travel to be recognized as a valid movement.
	private const float MouseMovementThreshold = 10.0f;

	/// <summary>
	/// Vertices of the concave hull based on the shape drawn by the user (unordered)
	/// </summary>
	private List<Vector3> _userDrawnHullVertices;
	
	/// <summary>
	/// Lines of the concave hull based on the shape drawn by the user (unordered),
	/// for visualization purposes only.
	/// </summary>
	private List<Vector3[]> _userDrawnHullLines;

	private List<GameObject> _currentButtons;

	private int _numObjects;

	public bool WaitingButtonClick { get; private set; }

	// Constants for concave hull
    private const double Concavity = 0.2;
	private const int ScaleFactor = 100;

	private PointCloudGenerator _pointCloudGenerator;

	// Width of line of user's drawing
	private const float LineWidth = 5.0f;

    private MovementControl movement_control;

	// Start is called before the first frame update
	void Start()
    {
        _userDrawnShapePoints = new List<Vector3>();
        _userDrawnHullVertices = new List<Vector3>();
        _userDrawnHullLines = new List<Vector3[]>();
        _currentButtons = new List<GameObject>();
        _pointCloudGenerator = GetComponent<PointCloudGenerator>();
        movement_control = GetComponent<MovementControl>();
    }

    // Update is called once per frame
    void Update()
    {
	    if (WaitingButtonClick || movement_control.IsMoving()) return;
	    
        if (Input.GetMouseButtonDown(0)) {  // First left click
            StartDrawing();
        } else if (Input.GetMouseButton(0)) {  // Dragging mouse
            InDrawing();
        } else if (Input.GetMouseButtonUp(0)) {  // Release mouse
            EndDrawing();
        }
    }
    
    private void StartDrawing()
    {
	    _userDrawnShapePoints.Add(Input.mousePosition);
    }

    private void InDrawing()
    {
        _userDrawnShapePoints.Add(Input.mousePosition);
    }

    /// <summary>
    /// Record the new selection region & create pop-up menu.
    /// </summary>
    private void EndDrawing()
    {
	    // If the shape drawn is not valid, forget about it.
	    if (!IsValidShape())
	    {
		    _userDrawnShapePoints.Clear();
		    return;
	    }
	    
	    // Generate hull using points drawn by the user.
	    var hullLines = HullGenerator.Compute(_userDrawnShapePoints, Concavity, ScaleFactor);
	    _userDrawnHullVertices = HullGenerator.CastLineListToPoints(hullLines);
	    _userDrawnHullLines = HullGenerator.CastLineListToVecArrays(hullLines);
	    
	    // Stop showing the line drawn by the user.
	    _userDrawnShapePoints.Clear();

	    // If there's no object selected, create one.
	    if (_numObjects == 0)
	    {
		    SelectionButtonClicked(0);
	    }
	    else  // If there are already objects, display the pop-up menu and let the user choose.
	    {
		    Assert.IsTrue(_numObjects > 0);
		    CreatePopUpMenu();
	    }
	}

    /// <summary>
    /// Check if the shape drawn by the user is valid.
    /// </summary>
    /// <returns>True if the user-drawn shape is valid for processing.</returns>
    private bool IsValidShape()
    {
	    var numPoints = _userDrawnShapePoints.Count;  
	    if (numPoints < 3) return false;  // Need at least 3 points to make a shape.
	    
	    var startPos = _userDrawnShapePoints[0];
	    var endPos = _userDrawnShapePoints[numPoints - 1];
	    // Shape invalid if mouse movement too slight and too few points registered. Otherwise valid.
	    return Vector3.Distance(startPos, endPos) >= MouseMovementThreshold || numPoints > 20;
    }
    
    /// <summary>
    /// Draw selection shape
    /// </summary>
    private void OnGUI()
    {
	    Handles.color = Color.red;
	    if (WaitingButtonClick)
	    {
		    // The concave hull generated by the user's drawing
		    foreach (var line in _userDrawnHullLines)
		    {
			    var from = ConvertMousePosToHandlesCoordinate(line[0]);
			    var to = ConvertMousePosToHandlesCoordinate(line[1]);
			    Handles.DrawLine(from, to);
		    }
	    }
	    else
	    {
			// The current line being drawn by the user.
			Handles.DrawAAPolyLine(LineWidth, 
			    _userDrawnShapePoints.Select(ConvertMousePosToHandlesCoordinate).ToArray());		    
	    }
    }
    
    /// <summary>
    /// Erase user-drawn shape and clear object indices.
    /// </summary>
    public void Reset()
    {
	    _userDrawnShapePoints = new List<Vector3>();
        _userDrawnHullVertices = new List<Vector3>();
        _userDrawnHullLines = new List<Vector3[]>();
        _currentButtons = new List<GameObject>();
        _numObjects = 0;
        WaitingButtonClick = false;
        _pointCloudGenerator.Reset();
    }

    /// <summary>
    /// Convert a mouse position to Handles coordinate system.
    /// </summary>
    /// <param name="mousePos">Mouse position vector.</param>
    /// <returns>Mouse position in Handles coordinate system.</returns>
    private static Vector3 ConvertMousePosToHandlesCoordinate(Vector3 mousePos)
    {
	    return new Vector3(mousePos.x, Screen.height - mousePos.y);
    }

    // Create PopUp Menu for Object Selection
    private void CreatePopUpMenu()
	{	
		WaitingButtonClick = true;

		for (var i = 0; i <= _numObjects; i++)
		{
			CreateButton(i);
		}
		
		popupMenu.SetActive(true);
	}

    /// <summary>
    /// Create a selection button.
    /// </summary>
    /// <param name="idx">Object index associated with the button.</param>
    private void CreateButton(int idx)
    {
	    // Create a new button as a child of pop-up menu
	    var newButton = Instantiate(indexButton, popupMenu.transform, false);
	    newButton.GetComponent<Button>().onClick.AddListener(
		    () => { SelectionButtonClicked(idx); }
	    );
	    _currentButtons.Add(newButton);
	    newButton.GetComponentInChildren<Text>().text = idx < _numObjects ? (idx + 1).ToString() : "New";
	    newButton.GetComponentInChildren<Text>().color = BoxVisualizer.VisColors[idx];
	    Console.WriteLine("Button Created");
	    newButton.SetActive(true);   
    }

    /// <summary>
    /// Callback function invoked when selection button in pop-up menu is clicked.
    /// </summary>
    /// <param name="objIdx">The index of the button clicked.</param>
    private void SelectionButtonClicked(int objIdx)
	{
		if (objIdx == _numObjects) // If "New" clicked
		{
			_numObjects += 1;
			_pointCloudGenerator.AddNewPointCloud(_userDrawnHullVertices);
		}
		else  // If existing object is selected
		{
			_pointCloudGenerator.UpdateExistingPointCloud(_userDrawnHullVertices, objIdx);			
		}
		
		// Hide buttons
        foreach (var button in _currentButtons)
		{
			Destroy(button);
		}
		popupMenu.SetActive(false);
		WaitingButtonClick = false;
	}
}
